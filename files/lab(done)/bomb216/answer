We have to stand with our North Korean allies.
0 1 1 2 3 5
4 0
9 27
adeijm
3 1 5 6 2 4

总结：

phase_1:
1.看到一个地址被放入了传进strings_equal函数，用gdb查看这个地址存放的字符串即可。

phase_2:
1.read_six_number应该是函数名一样的功能，也就是读入6个整数。
2.认出(base,index,4)形式时数组，就知道读入的数据存放在了数组里面。
3.跳转指令实现了一个for循环，直接看汇编代码，就知道是在实现一个斐波那契数列计算。

phase_3:
1.查看sscanf格式的字符串，发现应该是"%d %d"，即输入两个整数参数。
2.容易发现是一个switch语句，范围7以内。
3.注意jmpq *0x402880(,%rax,8)是一个跳转表，用gdb查看即可，注意有可能看到的是10进制地址要自己转换。
4.把跳转表读出来，再弄清楚汇编代码推断switch分支也可，找到答案。
5.另外一个思路是随便输入一个参数然后跟着gdb nexti跑，计算出另一个参数。
6.当然，还有一个思路是逆向推理，从可以不爆炸的地方回推，直到找到入口条件(不唯一)。
7.第一遍做的时候我是思路5.6.结合，后来才知道3.里面查看跳转表的方法。

phase_4:
1.查看sscanf格式的字符串，发现应该是"%d %d"，即输入两个整数参数。
2.容易发现func4是一个递归，返回值必须是0x1b。
3.容易发现第二个参数必须是0x1b。
4.可以弄清楚func4在干什么，但是可能有点点绕，心不静估计很难做出来。
5.由于查看func4汇编就可以知道输入范围为0到14,7是一个特殊点，可以直接用gdb试出答案，不过很无聊。
6.第一遍做的时候我的思路是5.，感觉浪费了func4设计的苦心，但是func4太难了，实在搞不懂，再研究研究，希望能看出来。

phase_5:
1.容易发现要输入六个字符。
2.0x4028c0(,%rdx,4)应该是一张数表，查看它，果然是，把数表抄写下来。
3.从代码看是一个for循环，把数表一些下标加起来，得到0x43。
4.(%rbx,%rdx,1)形式的一个数组中%rbx来源于%rsi，说明%rsi很关键，经过跟踪发现这就是我们的输入。
5.那么，找到你想加的数表里的下标加起来是0x43，构造对应英文字母即可(当然不是英文字母也可)。

phase_6:
1.容易发现要输入六个整数。
2.这个题很长，但模块很明显。
3.第一模块是一个二重循环，发现输入要是1,2,3,4,5,6的一个排列。
4.第二模块看得出在构造链表，具体没懂的话可以跳过，查看一下链表的值就可以大致读一读汇编就看出功能。
5.第三模块是一个for循环，在判断%rbx和8(%rbx)的data域递减，那么很容易猜测答案是6,5,4,3,2,1，但是不是。
6.看一看%rbx会发现，data域装的不是1,2,3,4,5,6而是似乎在上一模块经过某种运算或去某个地方读出来的答案。
7.如果有耐心可以细读上一模块，否则直接从6.中把1,2,3,4,5,6对应的data读出来，排个序即可，就能做出答案。

phase_7:secret phase!
1.暂时没有发现。
2.有空研究一下汇编部分的phase_7，争取能进入隐藏关卡！
